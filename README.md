# CSI 2532 - Devoir 2 / lab 10

## Q1: Normalisation

```
F = {
 AB → C,
 C → D,
 D → A
}

R(A, B, C, D)
```

### a Trouver toutes les clés candidates de R

```
B can't be generated using F so B must be present in the candidate key.
(B)+ = B 
Test B → R False

(AB)+ = ABCD which means AB → R so AB is a candidate key
(BC)+ = BCDA which means BC → R so BC is a candidate key
(BD)+ = BDAC which means BD → R so BD is a candidate key

Candidate keys are {AB, BC, BD}.
```

## Q2: Dépendances fonctionnelles

|NIN		|contractNo	|hoursPerWeek	|eName			|hotelNo 	|hotelLocation	|
|-----------|-----------|---------------|---------------|-----------|---------------|
|113567WD	|C1024		|16				|John Smith 	| H25 		|Edinburgh		|
|234111XA	|C1024		|24				|Diane Hocine 	| H25 		|Edinburgh		|
|712670YD	|C1025		|28				|Sarah White 	| H4 		|Glasgow		|
|113567WD	|C1025		|16				|John Smith 	| H4 		|Glasgow		|

### a

```
Avec le NIN et le numéro du contrat (contractNo), on peut déterminer les heuresPerWeek que l'employé à travailler.

NIN, contractNo → heuresPerWeek
```

```
Le NIN permet également à l'entreprise de connaître le nom de l'employé (eName).

NIN → eName 
```

```
Utilisation de hotelNo on sait le lieu de l'hôtel.

hotelNo → hotelLocation
```

```
On sait le lieu de l'hôtel. Chaque contratNo est associé à un hôtel particulier, ce qui signifie qu'avec le contratNo on connaît également l' hotelNo

contratNo → hotelNo
```

```
F = {
	NIN, contractNo → heuresPerWeek,
	NIN → eName,
	hotelNo → hotelLocation,
	contratNo → hotelNo
}
```

### b Liste toutes les clés candidates

```
NIN, contractNo can't be generated by F so {NIN, contractNo} ⊆ Candidate Key.

(NIN, contractNo)+ 	= (NIN, contractNo, heuresPerWeek)
					= (NIN, contractNo, heuresPerWeek, eName)
					= (NIN, contractNo, heuresPerWeek, eName, hotelNo)
					= (NIN, contractNo, heuresPerWeek, eName, hotelNo, hotelLocation)

(NIN, contractNo) → R.

So the candidate key for R is (NIN, contractNo).
```



## Q3: Langues pures

```
Sailors(sid, sname, rating, age)
Reserves(sid, bid, day)
Boat(bid, bname, bcolor)
```

### a (RA) Listez les couleurs des bateaux réservés par Albert.

Column names allign so there shouldn't be a need for a where clause or on, on the join.
No need to filter the colors (already filtered).
```
π Boat.bcolor (σ Sailors.sname='Albert' (Sailors ⋈ Reserves ⋈ Boat))
```

### b (RA) Listez les identifiants de tous les marins ayant une évaluation (rating) d'au moins 8 ou un bateau réservé 103

```
π Salors.sid (σ Sailors.rating>=8 ∨ Reserves.bid=103 (Sailors ⋈ Reserves))
```

### c (TRC) Listez les noms et l'âge de tous les marins qui ont une évaluation inférieure à 3

```
{t | s∈Sailors ∧ t[sname]=s[sname] ∧ t[age]=s[age] ∧ s[rating]<3}
```

### d (RDC) Listez les identifiants de tous les bateaux réservés le 2019-04-28

```
{<bid> | <sid,bid,day> ∈ Reserves ∧ day='2019-04-28'}
```

### e (RDC) Listez les couleurs de tous les bateaux réservés par le marin Lubber

```
{<bcolor> | <bid,bname,bcolor> ∈ Boat ∧ ∃ <sid,bid2,day> ∈ Reserves (bid=bid2 ∧ ∃ <sid2,sname,..> ∈ Sailors (sname='Lubber' ^ sid=sid2)) }
```


## Q4: RAID

|déclaration|correspond à  |déclaration|
|---|---|---|
|1 - Je peux utiliser une technique RAID niveau 0 car| B |A - la tolérance aux pannes est importante pour mon application et je dois protéger mes données même si deux disques tombent en panne en même temps.|
|2 - Je peux utiliser une technique RAID niveau 1 car| D |B - je n'inquiet pas de perdre les données. Mon objectif principal est de pouvoir lire et écrire à grande vitesse.|
|3 - Je peux utiliser une technique RAID niveau 5 car| C |C - j'ai 6 disques disponibles mais j'ai besoin de la capacité de 5 d'entre eux ce qui signifie que je ne peux pas gaspier l'espace qu'un seul disque pour assurer la redondance.|
|4 - Je peux utiliser une technique RAID niveau 6 car| A |D - je n'ai que deux disques disponibles, ce qui représente plus du double de la capacité dont j'ai besoin pour mon application et je veut être capable de récupérer les données si nécessaire.|
|5 - Je préfère utiliser une approche paritaire plutôt qu'une approche miroir car| E |E - la tolérance aux pannes est importante pour mon application, mais je n'ai pas beaucoup d'espace disponible.|


## Q5: Arbre B+




## Q6: Index Bitmap

|Brand	|Type	|Color|Risk  |
|-------|-------|-----|------|
|Opel	|Corsa	|Grey |Low	 |
|Opel	|Corsa	|Red  |Medium|
|Peugeot|206	|Black|Medium|
|BMW	|A 		|Black|High	 |

### a Construisez un index bitmap pour les attributs marque (Brand) et coleur (Color) de ce tableau

#### Brand
|		|0	|1	|2	|3	|
|-------|---|---|---|---|
|Opel	|YES|YES|NO |NO |
|Peugeot|NO |NO |YES|NO |
|BMW	|NO |NO |NO |YES|

#### Color
|		|0	|1	|2	|3	|
|-------|---|---|---|---|
|Grey	|YES|No |NO |NO |
|Red 	|NO |YES|NO |NO |
|Black	|NO |NO |YES|YES|

#### b Montrez comment les indices bitmap peuvent être utilisés pour répondre aux requêtes:




## Q7: Hachage

